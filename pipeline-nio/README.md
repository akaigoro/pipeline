pipeline-nio:
------------
asyncronous network I/O, based on NIO2. Provides two basic classes:

AsyncSocketChannel
------------------
represents a network connection and contains 2 classes:
Source<ByteBuffer> reader - to be used as the first node in a network-connected pipeline 
Sink<ByteBuffer> writer - to be used as the last node in a network-connected pipeline 

It can be used both on client and server sides.

AsyncServerSocketChannel
-----------------------
 - implements Source<AsyncSocketChannel>.
 
Generates accepted connections to clients on server side.

To obtain AsyncSocketChannel on a client side, simply instantiate it with a constructor,
then use its reader and writer in pipelines:
<pre>
    SocketAddress addr=...
    AsyncSocketChannel connection=new AsyncSocketChannel(addr);
    Pipeline inbound=new Pipeline()
    	.setSource(channel.reader)
        .addTransformer(...)
        .setSink(...)
        .start();
        
    Pipeline outbound=new Pipeline()
    	.setSource(...)
        .addTransformer(...)
        .setSink(channel.writer)
        .start();
</pre>

On server side, AsyncSocketChannels are generated by AsyncServerSocketChannel.
User must provide an implementation of Sink<AsyncSocketChannel> to make piplines
which handle client connections: 
<pre>
	SocketAddress addr=...
	int connNumber=1000; // max number of active connections
	AsyncServerSocketChannel acceptor=new AsyncServerSocketChannel(addr, connNumber);
	new Pipeline()
    	.setSource(acceptor)
        .setSink(new Service())
        .start();
    ...
    class Service extends SinkNode<AsyncSocketChannel> {
        @Override
        protected void act(AsyncSocketChannel channel) {
            channel.reader.injectBuffers(2, BUF_SIZE);
            new Pipeline()
            .setSource(channel.reader)
	        .addTransformer(new MyTransformer())
            .setSink(channel.writer)
            .start();
        }
	}
	
	clas MyTransformer extends BufTransformer {
    	protected CoderResult transformBuffers(I inbuf, O outbuf){
    	}

		// input stream of biffers is closed, flush the last buffer
	    protected CoderResult completeBuffer(O outbuf) {
	    	...
	    	context.post(null);
	    }
	}
</pre>
Some notes on the code:

Class Service extends SinkNode which is an impelmentation of Sink
based on class Actor from df4-core project. This is recommended implementation,
thought programmer is free to make his own. Actor's act(message) method is called when
the actor has received a message, here an instance of AsyncSocketChannel.
Invocation of method injectBuffers(2, BUF_SIZE) creates 2 buffers for reader.
Reader does not creates buffers implicitly, in order not to waste memory if next node in line  
(here an instance of MyTransformer) works slowly.

It is responsibility of each Sink to return all received messages back to Source
as soon asthey are processed. It is done with SyncNode's method free().
Class BufTransformer is a special implementation of interface Transforemer
which takes care of returning buffers.
Using other implementations, it is responsibility of programmer.

Likewise, when communucation with client is finished, the instance of AsyncSocketChannel
should be returned to AsyncServerSocketChannel, so that it could continue to accept
client connections knowing that maximum number of active connections is not exceeded.
It is done with AsyncSocketChannel.close(). Both AsyncSocketChannel.reader and
AsyncSocketChannel.writer do so when they are closed, and they are closed when
pipeline (being a CompletableFuture) is completed. Inside each node, pipeline is acessible
via variable conext, so context.post(null) completes pipeline normally.



